These guys:
  -- http://jsonsh.com/

o apidoc does not render and we cant ctrl-c once we try

o What is atom error when _type is wrong?

o https://github.com/json-schema/json-schema/wiki

o read: http://expressjs.com/en/advanced/best-practice-performance.html

o fix BSON in carbon-io.js

o add flag to Endpoint to control whether validate responses?

o What if you need a fiber before _main is called?....

o Collection.views
  - Should views be in Operation?

o _type: undefined (where for example carbon.carbond.Foo is not real)
causes very subtle bugs. Should we not allow undefined? Must say Object?

o what's up with deprecated options in Atom?

o better async testing
o dont use _endpoint.performOperation in HttpTest

o https://mixmax.com/blog/node-fibers-using-synchronize-js

o count for tests to make sure they all finish
    
o how do we protect against multiple _mains called in object graph of
module.export?
 -- like a nested object

-- still dont properly allow for account for async doStart and doStop

o how do you do a count on a collection (mongodb collection)

- We should then remove __ require mod as arg, and mainOnlyContext
   - Go back to line 337 in atom.js
- Means that you no longer need to run __() for top-level

-----------------------------------------

o rename fiber -> fibers
o include fibrous in fibers and have story around how to use it (and doc)

o Contact list example
 
***** FLEET GATEWAY USES DATAACL ******************

o make client._performOperation or something like it that is better
for clients

o Atom create _serviceName? or _componentName ? Might not be possible.

o Maybe have all 500 errors get logged (do this high up)

o clean bottom of Endpount._initializeOperation
  - should I always set back?

o leafnode: collection.drop throws exception if collection does not
exist

o Think about how we enable / disable MongoDBCollection methods. 
 - Use enabled: 
 - Use  update: undefined, 
 - I think enabled: more obvious what is going on
- enabled / disabled support at runtime
o Do we want Collection.supportsX / enabled.foo to work at runtime?

o Collection._assignInitialInstanceAcl -- kill that for now

o {ok:1} in firewall town

o null return from REST call. is that ok? case was query with fo=true
in original REST API. Maybe just dont support that here but in general
what should rule be?

o clean up db vs dbUri vs _db in MongoDBCollection (vs
db). Confusing. Docs also wrong.

o client.Collection.getFullUrl (why not with Endpoint?) Why?

o client toArray() needs { exhaust: true } or just exhaust param which
defaults to false. Right now toArray rips through / exhausts by
default. But maybe not? If you use skip and limit it toArray
is just that. hmmmm.
   - Use case of client. It just wants to display one page of results
   to browser. If we cant say exhaust:false, then we cant use
   toArray(). No dummy use skip limit. 
-- NOTE: toARrray in driver with limit does not exhaust
         with CC it does exhaust past limit (b/c of default limit)
         driver default limit is infinite.
Maybe customer should control pagination
Lib needs to buffer, but not the same as end user skip and limit
Maybe toArray has no buffer limit 
toArray always exhausts?
  - most similar to driver

o debug mode can leak api keys
  - dont have it print env or private env

o kill if (operation.service)

o is console logging async?
   https://groups.google.com/forum/#!topic/nodejs/jIXC2uGh9YU
   https://o2js.com/a-little-known-secret-of-the-console

o Also (related) do we check if insert is bulk or not? Maybe not
support in Collection....

o FACTORING IMPROVEMENTS
  * fix defineExpressRoute 
  * endpoint._init handle?
  * maybe Operation.service should handle validation and everything no?

o COLLECTION 
o Flesh out api for MongoDBCollections to be like current data api
(with AC)

o write up something explaining how you should not have fields defined
with oo 

AC 
-------------------------
o Endpoint.sanitizesOutput
o make sure you cant change obj[ownerField]. Could be big hole
o rm dynamic spec stuff from acl
o   - maybe not? what if role:Editor says write false but owner says
      write true? Dont want and semantics
o Errors from sanitize (sort of good for now?)
o impl write portion for obj acl 
o impl full proper sanitize (properties + recursive w no loops) 
o Clean up 'options' in acl (not needed) 
  --
  http://iankent.uk/2014/02/11/globally-handling-options-requests-in-play-framework/

o finish root user impl 
  - have sep header for root auth 
  - maybe what we do is take secret-key and the up to configurer 
  whether they want root-access-key. If they do it's 2-factor 
  potentially (when split config and flag passed). If they 
  don't want to use root-access-key root-secret-key becomes a single 
  value api key?

====================================================================================================
-- MED

o mini-guides 
  - how to extend a MongoDBCollection

o UserCollection 
  o creating new user 

o log rotation (in upstart?)

o _o("template:") 

o _o("service:") (to use Service Discovery) 

o Service discovery should always also include version
o leafnode async
o fibrous
o Views and Forms and Commands
o property cmdArgs non boolean (name value) 
o add dbUri and dbUris cmdArgs 
o remember changing schema of acls that will be in people's data is hard....
o UserOwnedMDBCollection
o Auth / AC per endpoint? Telemetry example is a good one
o Client Authentication vs User Authenication (authentication) 
   - how do we do ACL? 
   - Oath?
o envelope format / _links
o we took initDBs out of init. Hels with help. Is this ok? Composite 
object servers?
o Make sure you cant, as a client, use HTTP Method foo and end up
calling endpoint.foo (security)
o 405 Method Not Allowed
  - not sure we can do this since there is no route registered with
  express if no method. 
o MongoDBDatabase endpoint
  - I think we should be able to re-use MongoDBCollections even if we
  are lazy to create them, but might choose to impl not lazy collction creation?
o CORS security review
  - http://docs.strongloop.com/display/public/LB/Security+considerations

-- LATER
o Lattice
o LRU cache endpoint based on a field
o How does one make /bin wrappers. shebang or bsh?
o socket.io
o shell
o client cmdline
o CREATE method
o api-hub (carbon.io/api-hub)

PUNTED?
o indexes. maybe allow def on OS and have flags for auto-create vs
having to run command vs nothing


------ main booty
https://www.npmjs.com/package/lone (eh seems complex)
http://stackoverflow.com/questions/9449485/node-js-native-module-third-party-main-not-working (gyp)
   https://github.com/joyent/node/blob/master/node.gyp
http://qnalist.com/questions/5517523/tutorial-one-hackish-way-to-compile-js-and-native-addons-into-nodejs

--------------------
Creating users: how do we control the object created and how do we
control DOS?
   - just make it artificially slow? 
   - ip throttling? (Good for DOS but not DDOS)
   - Schema on post / insert good enough?
     - WAIT -- maybe use default acl template to define what fields
     they can write to... that is clean
       -- and then maybe for User collections you forbit the client
       from inserting a doc with an acl
     - adding custom fields? -- override insert and call
     this._super('insert')(newO)
     - or insertXform: function(obj) { ... } // maybe I both like and
     say why is this needed if you can _super?
   - How do you get a new user id? Just do ObjectId or let user
     - create involved? i think so even if there is no CREATE HTTP
     verb -- still who calls create, client or insert... hmmmm
     complicated more I think about it
   select? Offer other sequence generators? This generic for all
   collections? OS must make _id -- should also allow to be supplied
  

Example default user acl:

{ 
  aclTemplate: {
    "*": { 
       read: {
         _id: true,
         username: true,
         '*': false
       },
       write: false
    },
    "user:@req.user._id": { // which came from create(). Maybe better
                          // or should it just be <owner>?
    "__owner__": { // which came from create(). Maybe better

       read: {
          "secretField": false
          "*": true // needed since otherwise no field mention is false
       },
       write: {
         username: true, 
         password: true,
         email: true,
         "*": false // would be implied if absent
       } 
     
     }
   }
}

Do we want to make calling create() a formal part of the process?

Should this be the default of create() (or the wrapper to create):

create: function() {
  var result = {
    _id: this.generateId(),
  }

  result.__acl__ = newAcl(result) // so that the generator has the
                                  // user _id and whatever else is needed in the template
}

But you can write:

create: function(req) { // want req? ideally no. maybe create(user)?
   return {
      _id: this.generateId() // should this be in wrapper too?
      password: "passwordchangeme",
      organization: this.
   }
}

Another idea is have req.user be { _id: <id>, __acl__: <acl> } on the
request at right times (like when using User collection)


-----

Blogger

http://webcache.googleusercontent.com/search?q=cache:vlJ_IH4ZBP4J:npmawesome.com/posts/2014-04-29-compare-express-restify-hapi-loopback/+&cd=8&hl=en&ct=clnk&gl=us
-----

ClassDOjo?
http://caines.ca/blog/2013/04/29/so-i-wrote-a-json-api-framework-and-the-framework-was-the-least-interesting-part/

----------
Could this be easier?

__(function() {
  module.exports = o({
    _type: carbon.carbond.ObjectServer,
    port: 8888,
    dbUri: "mongodb://will:will@ds049150.mongolab.com:49150/datanode-sandbox",
    endpoints : {
      "zipcodes": o({
        _type: carbon.carbond.MongoDBCollection
        collection: "zipcodes"
      })
    }
  })
})

----------
o Errors 
  - http://dailyjs.com/2014/01/30/exception-error/
----------
o JSON schema
  - http://spacetelescope.github.io/understanding-json-schema/index.html

----------
setuid
  - https://thomashunter.name/blog/drop-root-privileges-in-node-js/
  - http://syskall.com/dont-run-node-dot-js-as-root/ (dont do this)

ssl
http://www.gettingcirrius.com/2012/06/securing-nodejs-and-express-with-ssl.html

great API docs
  http://getkong.org/docs/0.2.0-2/admin-api/


Should we use ejson vs mongodb-extended-json

Firebase port to mongo todo app

http://thejackalofjavascript.com/re-architecting-a-firebase-app-in-node/

RFC
   http://tools.ietf.org/html/rfc7231#page-26

PUT vs PATCH
  http://restful-api-design.readthedocs.org/en/latest/methods.html
 
Proper responses
   http://stackoverflow.com/questions/797834/should-a-restful-put-operation-return-something

Hashing api keys
  https://octopusdeploy.com/blog/hashing-api-keys

---
Proxy protocol
http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/enable-proxy-protocol.html

Coolness?
http://assemble.io/

api docs
http://www.mattsilverman.com/2013/02/tools-to-generate-beautiful-api-documentation.html

o Service disovery 
provisionerService: _o(_o('http://serviced.mlab.io:6767/environments/production/ProvisionerService')), {}),
  - http://jasonwilder.com/blog/2014/02/04/service-discovery-in-the-cloud/
  - https://labs.spotify.com/2013/02/25/in-praise-of-boring-technology/
  ** _o('service:provisioner', {})

Merge / branch in git 
- http://nvie.com/posts/a-successful-git-branching-model/
 
---------------------

In github -- b/c that is what software defined means

-- checked in and version controlled like rest of code
-- intended state of system as a whole is always considered and
reasoned about, vs piecemeal
-- easy to create many copies of the same system
-- Need variables like #{foo}

System
{
  provider: {
    type: "AWS",
    secretKey: "",
  }              
  
  // OR should this be a tree with sub-systems and services as leaves?
  // The below are nice tho in that they abstract away cluster and are 
  // abstrated as single services. Maybe services can be systems? 
  
  services: [
    {  // could this whole thing be in another file? yes
       type: "LoadBalancedServiceCluster", 
       name: "PublicAPI",
       public: true,
       loadBalanced: true, // needed? vs service discovery?
       cname: "api.acme.com",
       autoScale: false,
       numServiceInstances: 3,
       source: "git+http://.....",

       // port assignment config?

       resources: {
         cpus: 2,
         memory: 2000
       }
    },

    {
      _type: "Cluster" // or do we just say cluster? or is this even a cluster?
      name: "PrivateAPI",
      public: true,
      loadBalanced: false, // needed? vs service discovery?
      cnameTemplate: "private-api-{n}.acme.com",
      autoScale: false, // Is the true case a good case for service discovery?
      numServiceInstances: 2,
      image: "http://.....", // docker image (or git uri better?) 
      ram: ">= 32GB" // like semvar? Or don get fancy?
    },
  
    {
      _type: "PanamaCluster",
      name: "Panama",
      ...
      ... 
    },

    {
      _type: "ControlBox",
      name: "walker",
         
    }       
  ],
}

Example of templating:

ProductionCluster.json 
{
  "$include": "./WebClusterTemplate.json", // Should this be involved in how we make new "types"?
  "params": {
    "numServicePrivateApiServiceInstances": 3,
    "accountId": "production-account",
    "secretKey": "1234",
  }  
}

ProductionCluster.json 
{
  "$ref": "./WebClusterTemplate",
  "numServicePrivateApiServiceInstances": 3,
  "accountId": "production-account",
  "secretKey": "1234"
  }  
}

ProductionCluster.json 
{
  "type": "./WebClusterTemplate",

  "numServicePrivateApiServiceInstances": 3,
  "accountId": "production-account",
  "secretKey": "1234"
  }  
}

WebClusterTemplate.json
{

  provider: {
    type: AWS,
    accountId: "#{accountId}",
    secretKey: "#{secretKey}"
  }

  services: [
    {
      type: "Cluster",
      name: "PrivateAPI",  
      public: true,
      numServiceInstances: "#{numServicePrivateApiServiceInstances}"
    }
  ]

}


----------------------

Testing

var result = testOp({ url: "http://localhost:8080",
         method: "GET",
         parameters: {
           x: 1
         },
         body: {},
         headers: {}
       },
       {
          statusCode: 201,
          data: { x: 1 }
          headers: function(headers) { return headers.foo < 2 } 
       }           
}                    


Test
  :name
  :desc
  run(done) 

TestSuite <- Test
   (name)
   (desc)
   tests: []
   run(done) --> tests.foreach((test) -> test.run(done))

MyTest
  run(done) {...}



var mockLabServer = o({
  _type: ObjectServer,
  port: 8888,
  endpoints: [
    status: {
       get: function(req) {
          return { ... }
       }
    }
  ]
})


--------------------------

reposnses: [
  {
    statusCode: 201,
    description: "Added",
    schema: {}
  },
  
]

--------------------------

publicDirectories: {
  images: "imgs",
  
}
