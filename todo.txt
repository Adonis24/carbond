For MongoHost agent
   - have it present its server cert to private api and have privae
   api validate key (client validation)

o How do we do peer cert validation with ELB
  o Use TCP?
o restify and api versioning
o look into rotate madmin key

o change www to public 

Endpoint.getEndpoint()?

o start() sync is all messed up

In client when trying to PUT when that method is not supported
  Error: Cannot PUT /basic?query%5Bx%5D=hello&amp;query%5By%5D=goodbye

o Service discovery should always also include version

Core 
-------------------------

o read: http://expressjs.com/en/advanced/best-practice-performance.html
 
o ENV
  - Declare env variables in cmdOptions or top-level like cmdOptions
  - Have Atom remove them from process.env and store somewhere else
  (configurable whether they should be removed)
  - Have env: go to that other place

***** FLEET GATEWAY USES DATAACL ******************

o make client._performOperation or something like it that is better
for clients

o Do we consider ObjectServer.start() to be blocking or no? i.e. when
it returns are we listening?

o Atom create _serviceName? or _componentName ? Might not be possible.

o Maybe have all 500 errors get logged (do this high up)

o clean bottom of Endpount._initializeOperation
  - should I always set back?

o In order to validate response when service(req, res)
  we may need a response wrapper

o remove lib path  thing in atom

o leafnode: collection.drop throws exception if collection does not
exist

o should be able to return undefined from operation cant now (See
MDBCollection.updateObject)
  - maybe use our Undefined EJSON type?

o ObjectServer --> Service

o Add runCommand to MongoDB collections (or have some way to do
findAndMod and other goodies)

o Think about how we enable / disable MongoDBCollection methods. 
 - Use enabled: 
 - Use  update: undefined, 
 - I think enabled: more obvious what is going on

o leafnode runCommand

o Who makes _id a thing? Collections? Or MongoDBCollections?
  - Not sure it should be Collection
  - But nice in collection. Maybe make _id special and 
    make required when on responseSchemas and save but not insert?
    And on save validate _id is path id
  - This seems like a sane thing since Collection inherintly 
    has concept of <c>/<id>....
*** sometimes we want _id required on insert (like zipcodes)

o Add testing idPathParameter to stuff in advanced-collection-tests

o Do we want Collection.supportsX / enabled.foo to work at runtime?

o middleware

o Collection._assignInitialInstanceAcl -- kill that for now

o Collection.insert 201

o Change allow unauthenticated to boolean 

o Collection should not bring in query skip limit. Do that
in MDBC. Just make sure every CollectionOp can have parameters.

o Add OpParameters. Issue I see is with doX vs service. Need 
to now have enough context to call right method. AND if we do this
should it be the same for Endpoint and have doGet?

o {ok:1} in firewall town

o null return from REST call. is that ok? case was query with fo=true
in original REST API. Maybe just dont support that here but in general
what should rule be?

o Deal with encryption / hashing in authenticators

o Response obj and response schema? Do we want to validate objects 
going out?

o finish OP.resolver or not. what was the issue again? I think it 
was not having a way to get at both the parameter and the raw value

o should be able to add parameters to a Collection (question is query 
vs update vs delete)

o query schema apply to update and delete?

o Endpoint.getOperation 

o desc for Endpoint and Operation 

o clean up db vs dbUri vs _db in MongoDBCollection (vs
db). Confusing. Docs also wrong.

o client.Collection.getFullUrl

o errors nest in client responses

o log rotation (in upstart?)

o client toArray() needs { exhaust: true } or just exhaust param which
defaults to false. Right now toArray rips through / exhausts by
default. But maybe not? If you use skip and limit it toArray
is just that. hmmmm.
   - Use case of client. It just wants to display one page of results
   to browser. If we cant say exhaust:false, then we cant use
   toArray(). No dummy use skip limit. 
-- NOTE: toARrray in driver with limit does not exhaust
         with CC it does exhaust past limit (b/c of default limit)
         driver default limit is infinite.
Maybe customer should control pagination
Lib needs to buffer, but not the same as end user skip and limit
Maybe toArray has no buffer limit 
toArray always exhausts?
  - most similar to driver

o 404s for collection object methods

o deal with _id in schemas in collecions (insert vs other ...)

o patch and put seem to simply not work

o generate examples for schemas. first just allow static examples?
  https://www.npmjs.com/package/json-schema-faker

o do we want body parser given we want to parse EJSON?

o bump express body size max

o debug mode can leak api keys
  - dont have it print env or private env

o required fields for ObjectServer (atom thing)

MONGOLAB PRIVATE API
  o env choose better variable prefix
  o take out dev uri

o redo atom inheritence tests

o dataAcl should not be on ENdpoint should it?

PARAMETER PARSING
===================================================
o parameter parser not parsing numbers properly (or booleans) 

o request qs and querystring cause JSON query params to come out very  
strange (to me :)  
   - http://blog.websecurify.com/2014/08/hacking-nodejs-and-mongodb.html  
    qs: _.mapValues(options.params, function(param) { return JSON.stringify(param) }),
o desupport a=1, a=2
o ParameterParser class and unit tests. 
  - Whole section of docs on how we do parameter parseing vs qs. What
  we support -- what is configurable. Right now I think if we stringfy
  json on carbon client the server can support our style and
  qs. Unclear if we want to make sq configurable. 

o POST without JSON body (string in body) no client error

o private env prefix should be different

o JSON injection
  o carbon only accept application/json (or make default?)
  o query params with array love is evil. can make things objects

o watch for method spoofing as way to invoke methods in code 

o better examples of using _init in class in Atom docs

o Deal with encryption / hashing in authenticators

o kill if (operation.service)

o .json vs .send

o is console logging async?
   https://groups.google.com/forum/#!topic/nodejs/jIXC2uGh9YU

o Do we really want idGenerator when we have upsert? 
o Also (related) do we check if insert is bulk or not? Maybe not
support in Collection....

o static files dir

o FACTORING IMPROVEMENTS
  * fix defineExpressRoute 
  * endpoint._init handle?
  * maybe Operation.service should handle validation and everything no?

o COLLECTION 
o Flesh out api for MongoDBCollections to be like current data api
(with AC)

o ObjectServer must be run in fiber now. That needed?
  - a little more subtle. it is more that now ObjectServer if in main
  test as variable calls main. This is confusing. Maybe only when
  module.exports is equal to the object? Is there race there? Yea I
  think so -- I think main is called before o() returns. 
 * Related: maybe make OS.start() idempotent at least
 * maybe var o = carbon.atom.o(module).main

o write up something explaining how you should not have fields defined
with oo 

o http://json5.org/

Important unit tests
-------------------------
o private env
o acl stuff
o parameter parsing

AC 
-------------------------
o Endpoint.sanitizesOutput
o make sure you cant change obj[ownerField]. Could be big hole
o rm dynamic spec stuff from acl
o   - maybe not? what if role:Editor says write false but owner says
      write true? Dont want and semantics
o Errors from sanitize (sort of good for now?)
o impl write portion for obj acl 
o impl full proper sanitize (properties + recursive w no loops) 
o Clean up 'options' in acl (not needed) 
  --
  http://iankent.uk/2014/02/11/globally-handling-options-requests-in-play-framework/

o decide on /lib/ shorcut in atom

o finish root user impl 
  - have sep header for root auth 
  - maybe what we do is take secret-key and the up to configurer 
  whether they want root-access-key. If they do it's 2-factor 
  potentially (when split config and flag passed). If they 
  don't want to use root-access-key root-secret-key becomes a single 
  value api key?

-- SWAGGER

o Swagger Issues
  - in swagger ui if you do an obj get with no id the request url is 
    odd. Think this is swagger bug (http://Wills-MacBook-Pro.local:8888/zipcodes/{id})
  - What's up with swagger and :id? vs :id
o Swagger ui and auth 
  - root auth
  - drive client auth from this (if possible) 
    https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md#securityDefinitionsObject


-- BUGS
o BUGS 
o if you send non escaped params in query string server freaks 
  [15-04-26|14:03:56]% curl 'localhost:8888/hello?message="Nice "' 
  curl: (52) Empty reply from server 
    http://stackoverflow.com/questions/18157117/node-js-curl-52-empty-reply-from-server-with-space-in-request-not-encoded

o invalid json sent in body fails body parser in non-friendly way 
(should be able to get out to client...) 
SyntaxError: Unexpected string 
    at Object.parse (native) 
    at parse (/Users/will/src/github/carbon-io/carbond/node_modules/body-parser/lib/types/json.js:84:17) 
    at /Users/will/src/github/carbon-io/carbond/node_modules/body-parser/lib/read.js:102:18 
    at IncomingMessage.onEnd (/Users/will/src/github/carbon-io/carbond/node_modules/body-parser/node_modules/raw-body/index.js:149:7) 
    at IncomingMessage.g (events.js:180:16) 
    at IncomingMessage.EventEmitter.emit (events.js:92:17) 
    at _stream_readable.js:920:16 
    at process._tickCallback (node.js:415:13) 


-- DOC
o document logging in ObjectServer
o document in atom how to pass constructor args, how they chain and _init 
o sslOptions
o json schema stuff
o mini-guides
  - how to extend a MongoDBCollection

====================================================================================================
-- MED

o UserCollection 
  o creating new user 

o _o("template:") 

o _o("service:") (to use Service Discovery) 

o leafnode async
o fibrous
o Views and Forms and Commands
o property cmdArgs non boolean (name value) 
o add dbUri and dbUris cmdArgs 
o remember changing schema of acls that will be in people's data is hard....
o UserOwnedMDBCollection
o Auth / AC per endpoint? Telemetry example is a good one
o Client Authentication vs User Authenication (authentication) 
   - how do we do ACL? 
   - Oath?
o envelope format / _links
o we took initDBs out of init. Hels with help. Is this ok? Composite 
object servers?
o Responds with stuff in swagger spec (for errors etc...) 
o client 
o Make sure you cant, as a client, use HTTP Method foo and end up
calling endpoint.foo (security)
o Clean up response codes (201 for posts?) 
  http://blog.ploeh.dk/2013/04/30/rest-lesson-learned-avoid-204-responses/
o 201 location: on insert?
o 405 Method Not Allowed
  - not sure we can do this since there is no route registered with
  express if no method. 
o MongoDBDatabase endpoint
  - I think we should be able to re-use MongoDBCollections even if we
  are lazy to create them, but might choose to impl not lazy collction creation?
o CORS security review
  - http://docs.strongloop.com/display/public/LB/Security+considerations
o verify X-Powered-By is not express and make Carbon  

-- LATER
o Lattice
o LRU cache endpoint based on a field
o How does one make /bin wrappers. shebang or bsh?
o socket.io
o shell
o client cmdline
o CREATE method
o api-hub (carbon.io/api-hub)

PUNTED?
o indexes. maybe allow def on OS and have flags for auto-create vs
having to run command vs nothing


------ main booty
https://www.npmjs.com/package/lone (eh seems complex)
http://stackoverflow.com/questions/9449485/node-js-native-module-third-party-main-not-working (gyp)
   https://github.com/joyent/node/blob/master/node.gyp
http://qnalist.com/questions/5517523/tutorial-one-hackish-way-to-compile-js-and-native-addons-into-nodejs

--------------------
Creating users: how do we control the object created and how do we
control DOS?
   - just make it artificially slow? 
   - ip throttling? (Good for DOS but not DDOS)
   - Schema on post / insert good enough?
     - WAIT -- maybe use default acl template to define what fields
     they can write to... that is clean
       -- and then maybe for User collections you forbit the client
       from inserting a doc with an acl
     - adding custom fields? -- override insert and call
     this._super('insert')(newO)
     - or insertXform: function(obj) { ... } // maybe I both like and
     say why is this needed if you can _super?
   - How do you get a new user id? Just do ObjectId or let user
     - create involved? i think so even if there is no CREATE HTTP
     verb -- still who calls create, client or insert... hmmmm
     complicated more I think about it
   select? Offer other sequence generators? This generic for all
   collections? OS must make _id -- should also allow to be supplied
  

Example default user acl:

{ 
  aclTemplate: {
    "*": { 
       read: {
         _id: true,
         username: true,
         '*': false
       },
       write: false
    },
    "user:@req.user._id": { // which came from create(). Maybe better
                          // or should it just be <owner>?
    "__owner__": { // which came from create(). Maybe better

       read: {
          "secretField": false
          "*": true // needed since otherwise no field mention is false
       },
       write: {
         username: true, 
         password: true,
         email: true,
         "*": false // would be implied if absent
       } 
     
     }
   }
}

Do we want to make calling create() a formal part of the process?

Should this be the default of create() (or the wrapper to create):

create: function() {
  var result = {
    _id: this.generateId(),
  }

  result.__acl__ = newAcl(result) // so that the generator has the
                                  // user _id and whatever else is needed in the template
}

But you can write:

create: function(req) { // want req? ideally no. maybe create(user)?
   return {
      _id: this.generateId() // should this be in wrapper too?
      password: "passwordchangeme",
      organization: this.
   }
}

Another idea is have req.user be { _id: <id>, __acl__: <acl> } on the
request at right times (like when using User collection)


-----

Blogger

http://webcache.googleusercontent.com/search?q=cache:vlJ_IH4ZBP4J:npmawesome.com/posts/2014-04-29-compare-express-restify-hapi-loopback/+&cd=8&hl=en&ct=clnk&gl=us
-----

ClassDOjo?
http://caines.ca/blog/2013/04/29/so-i-wrote-a-json-api-framework-and-the-framework-was-the-least-interesting-part/

----------
Could this be easier?

__(function() {
  module.exports = o({
    _type: carbon.carbond.ObjectServer
    port: 8888,
    dbUri: "mongodb://will:will@ds049150.mongolab.com:49150/datanode-sandbox",
    endpoints : {
      "zipcodes": o({
        _type: carbon.carbond.MongoDBCollection
        collection: "zipcodes"
      })
    }
  })
})

----------
o Errors 
  - http://dailyjs.com/2014/01/30/exception-error/
----------
o JSON schema
  - http://spacetelescope.github.io/understanding-json-schema/index.html

----------
setuid
  - https://thomashunter.name/blog/drop-root-privileges-in-node-js/
  - http://syskall.com/dont-run-node-dot-js-as-root/ (dont do this)

ssl
http://www.gettingcirrius.com/2012/06/securing-nodejs-and-express-with-ssl.html

great API docs
  http://getkong.org/docs/0.2.0-2/admin-api/


Should we use ejson vs mongodb-extended-json

Firebase port to mongo todo app

http://thejackalofjavascript.com/re-architecting-a-firebase-app-in-node/

RFC
   http://tools.ietf.org/html/rfc7231#page-26

PUT vs PATCH
  http://restful-api-design.readthedocs.org/en/latest/methods.html
 
Proper responses
   http://stackoverflow.com/questions/797834/should-a-restful-put-operation-return-something

Hashing api keys
  https://octopusdeploy.com/blog/hashing-api-keys

---
Proxy protocol
http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/enable-proxy-protocol.html

Coolness?
http://assemble.io/

api docs
http://www.mattsilverman.com/2013/02/tools-to-generate-beautiful-api-documentation.html

o Service disovery 
provisionerService: _o(_o('http://serviced.mlab.io:6767/environments/production/ProvisionerService')), {}),
  - http://jasonwilder.com/blog/2014/02/04/service-discovery-in-the-cloud/
  - https://labs.spotify.com/2013/02/25/in-praise-of-boring-technology/
  ** _o('service:provisioner', {})

Merge / branch in git 
- http://nvie.com/posts/a-successful-git-branching-model/
 
---------------------

In github -- b/c that is what software defined means

-- checked in and version controlled like rest of code
-- intended state of system as a whole is always considered and
reasoned about, vs piecemeal
-- easy to create many copies of the same system
-- Need variables like #{foo}

System
{
  provider: {
    type: "AWS",
    secretKey: "",
  }              
  
  // OR should this be a tree with sub-systems and services as leaves?
  // The below are nice tho in that they abstract away cluster and are 
  // abstrated as single services. Maybe services can be systems? 
  
  services: [
    {  // could this whole thing be in another file? yes
       type: "LoadBalancedServiceCluster", 
       name: "PublicAPI",
       public: true,
       loadBalanced: true, // needed? vs service discovery?
       cname: "api.acme.com",
       autoScale: false,
       numServiceInstances: 3,
       source: "git+http://.....",

       // port assignment config?

       resources: {
         cpus: 2,
         memory: 2000
       }
    },

    {
      _type: "Cluster" // or do we just say cluster? or is this even a cluster?
      name: "PrivateAPI",
      public: true,
      loadBalanced: false, // needed? vs service discovery?
      cnameTemplate: "private-api-{n}.acme.com",
      autoScale: false, // Is the true case a good case for service discovery?
      numServiceInstances: 2,
      image: "http://.....", // docker image (or git uri better?) 
      ram: ">= 32GB" // like semvar? Or don get fancy?
    },
  
    {
      _type: "PanamaCluster",
      name: "Panama",
      ...
      ... 
    },

    {
      _type: "ControlBox",
      name: "walker",
         
    }       
  ],
}

Example of templating:

ProductionCluster.json 
{
  "$include": "./WebClusterTemplate.json", // Should this be involved in how we make new "types"?
  "params": {
    "numServicePrivateApiServiceInstances": 3,
    "accountId": "production-account",
    "secretKey": "1234",
  }  
}

ProductionCluster.json 
{
  "$ref": "./WebClusterTemplate",
  "numServicePrivateApiServiceInstances": 3,
  "accountId": "production-account",
  "secretKey": "1234"
  }  
}

ProductionCluster.json 
{
  "type": "./WebClusterTemplate",

  "numServicePrivateApiServiceInstances": 3,
  "accountId": "production-account",
  "secretKey": "1234"
  }  
}

WebClusterTemplate.json
{

  provider: {
    type: AWS,
    accountId: "#{accountId}",
    secretKey: "#{secretKey}"
  }

  services: [
    {
      type: "Cluster",
      name: "PrivateAPI",  
      public: true,
      numServiceInstances: "#{numServicePrivateApiServiceInstances}"
    }
  ]

}


----------------------

Testing

var result = testOp({ url: "http://localhost:8080",
         method: "GET",
         parameters: {
           x: 1
         },
         body: {},
         headers: {}
       },
       {
          statusCode: 201,
          data: { x: 1 }
          headers: function(headers) { return headers.foo < 2 } 
       }           
}                    




