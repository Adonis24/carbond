Plan
  o start using just for internal microservices
  o then look at for apps

datanodes.io

Use cases:

o P: Your friends can see your User obj but not all fields
  S: /public-users and /private-users with different ACLs and different projections / xforms

o P: DOS attack by sending unindexed queries
  S1: Query permissions (coarse grained (like false))
  S2: "Data forms" but read version "Data Queries"
  S3: Endpoint rules on constrainable fields (might still not be enough (i.e. $ne DOS))
-----

o May need more fine grained permissions. Example, might want 'query' persmission to close collection endpoint (considering {} a query)
  Also the dual aof 'object' permission to see by ID. Combo powerful


DatanodeClient
  o MongoDBDatanodeClient
     - not full substitute for leafnode -- only when looking at
       mongodb as a datanode. if doing admin use leadnode
  o RESTDatanodeClient

But how do you interact with endpoints that are not collections? Maybe
you dont

Maybe DNs should be less open-ended. Only allowing for collections and
commands?

On server
Collections take one are (query) and endpoint pattern is
<root>[/?id][?<query>]
  doGetObject(id)
  doGetObjects(query, options)
  doInsert(o)
  doUpdateObjects(query, update)
  doUpdateObject(id, update)
  doSave(o)
  doDeleteObjects(query)
  doDeleteObject(id) 
  beforeX
  afterX or use super?

Command (POST) (should allow at any endpoint?)
  doCommand(cmd)

Dataforms and Data Views?

On client (allows callback and sync style)
   .<http-method>(path)? // lower lower leval? (or could be .getRESTClient())
   .getEndpoints() // this is lower level interface?
   .getCollection(n)
      .findById(id)
      .find(q, options)
      .findOne()
      .insert()
      .update(id, update)
      .save(o)
      .deleteById(id)
      .delete(query)
      .findAndModify()???? (later)
      
   .command(cmd)

.connect(uri)


var panama = datanode.connect("http://panama.mongolab.com")
panama.getCollection("events").insert(e)
panama.getCommand("shutdown").exec()
panama.command("shutdown", {})
panama.command("restart", {"wait": 1000})

cmdline (should it just work with o when given http url?)
% o http://localhost:8800/

-- Every serverside call (like form calls (but what about collections/cmds?)) get user id from client
   being authenticated. DatanodeClients used from browser need to
   authenticate for end user

-- Datanode support for Kerberos? That would be cool
------------------
------------------
Features
o main service
o declaritive argparse
o schema / ODM (these are different. one is schema one is object,
  binding (they should be consistent with each othr)
o autogenerated docs, with interactive examples, playground to try
  -- maybe each ObjectServer has an endpoint (default to /) that
  -- serves up this UI
  -- kind of like a data browser?
o automated testing of api
o automatic mocking of api
o automatic admin UI
o logging / request log / all ops log
o auditing (different?)
o monitoring (both alive-ness and performance and correctness (from
   --testdefs)
o auto /status endpoint plus pacemaker that calls status()
o auto profiling (linked to Telemetry)
o pluggable auth model (apikey, http basic, etc...)
o acl / security 
o autogen forms?
o proxy / load balancing
o datanode-client
o datanode shell (like mongo shell) (also restshell)?
o api versioning
o cursors for dbs
o RSS
o REST Envelope and non-envelope formats

Create a lot of examples

Doc up a list of Endpoint types with methods
  Endpoint
    Collection
    DataView / CollectionView *** OR SHOULD ALL COLLECTIONS HAVE VIEWS??????????????
       - maybe we do not need views on non data collections since if
        you want to make a view it should be easy enough subclassing
        Endpoint and using params
    DataForm / 
     

{
  _type: "datanode/CollectioView",
  collection: "todos",
  params: {
    color: {
       // swagger style? dont need everything (line "in" etc...)
    }
  },
  
  // query, queryTemplate, view, viewTemplate
  query: function(user, params) {
     return {
       query: { ... },
       sort: {},
       fields: {},
       ...
     }
  }
  
  query: {
     color: "@color",
     color: "@params.color",
     user: "@user.id"
  }

}

-------------------------

For Collections
   - supportsCollectionRead (find)
     - supportsCollectionQuery?
   - supportsCollectionUpdate (update)
   - supportsCollectionDelete (remove)
   - supportsObjectRead  (findById findOne)
   - supportsObjectCreate (insert)
   - supportsObjectUpdate (update, save)
   - supportsObjectDelete (removeById)

Tranforms?
  - Read transform (for collection and obj reads)
  - Write transform (for insert, update, and save) (or is update same
  as save?)

-------------------------

Inchworm example

supportsObjectCreate
supportsObjectRead
supportsObjectDelete

What is a View?
   

----------
Error handling

Maybe we define a BasicEndpoint that handles this:

{
  _type: 'datanode/BasicEndpoint',
  
  get: function(params, cb) {
     if (!params.foo) {
        cb(new InvalidParametersError("Foo parameter required"))
     } else {
       cb({foo: params.foo})
     }
  }
}

http://stackoverflow.com/questions/783818/how-do-i-create-a-custom-error-in-javascript
http://j-query.blogspot.com/2014/03/custom-error-objects-in-javascript.html

oo({
  _type: Error,
  code: 401
})

-------
% hexshell localhost:8080
> ls
todos users
> cd todos
> options // ls?
['get', 'post']
> GET
[...]
> POST {a: 1}
> this
{ ... meta ... }

o Can potentially use the Swagger spec that gets beamed
o Should also have non-interactive mode or another tool called hexc
that is more cmdline tool
o Maybe it should be a javascript shell? Like mongo? Ooooh
o 








