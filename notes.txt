Plan
  o start using just for internal microservices
  o then look at for apps

datanodes.io

Use cases:

o P: Your friends can see your User obj but not all fields
  S: /public-users and /private-users with different ACLs and different projections / xforms

o P: DOS attack by sending unindexed queries
  S1: Query permissions (coarse grained (like false))
  S2: "Data forms" but read version "Data Queries"
  S3: Endpoint rules on constrainable fields (might still not be enough (i.e. $ne DOS))
-----

o May need more fine grained permissions. Example, might want 'query' persmission to close collection endpoint (considering {} a query)
  Also the dual aof 'object' permission to see by ID. Combo powerful


DatanodeClient
  o MongoDBDatanodeClient
     - not full substitute for leafnode -- only when looking at
       mongodb as a datanode. if doing admin use leadnode
  o RESTDatanodeClient

But how do you interact with endpoints that are not collections? Maybe
you dont

Maybe DNs should be less open-ended. Only allowing for collections and
commands?

On server
Collections take one are (query) and endpoint pattern is
<root>[/?id][?<query>]
  doGetObject(id)
  doGetObjects(query, options)
  doInsert(o)
  doUpdateObjects(query, update)
  doUpdateObject(id, update)
  doSave(o)
  doDeleteObjects(query)
  doDeleteObject(id) 
  beforeX
  afterX or use super?

Command (POST) (should allow at any endpoint?)
  doCommand(cmd)

Dataforms and Data Views?

On client (allows callback and sync style)
   .<http-method>(path)? // lower lower leval? (or could be .getRESTClient())
   .getEndpoints() // this is lower level interface?
   .getCollection(n)
      .findById(id)
      .find(q, options)
      .findOne()
      .insert()
      .update(id, update)
      .save(o)
      .deleteById(id)
      .delete(query)
      .findAndModify()???? (later)
      
   .command(cmd)

.connect(uri)


var panama = datanode.connect("http://panama.mongolab.com")
panama.getCollection("events").insert(e)
panama.getCommand("shutdown").exec()
panama.command("shutdown", {})
panama.command("restart", {"wait": 1000})

cmdline (should it just work with o when given http url?)
% o http://localhost:8800/

-- Every serverside call (like form calls (but what about collections/cmds?)) get user id from client
   being authenticated. DatanodeClients used from browser need to
   authenticate for end user

-- Datanode support for Kerberos? That would be cool
------------------
------------------
Features
o main service
o declaritive argparse
o schema / ODM (these are different. one is schema one is object,
  binding (they should be consistent with each othr)
o autogenerated docs, with interactive examples, playground to try
  -- maybe each ObjectServer has an endpoint (default to /) that
  -- serves up this UI
  -- kind of like a data browser?
o automated testing of api
o automatic mocking of api
o automatic admin UI
o logging / request log / all ops log
o auditing (different?)
o monitoring (both alive-ness and performance and correctness (from
   --testdefs)
o auto /status endpoint plus pacemaker that calls status()
o auto profiling (linked to Telemetry)
o pluggable auth model (apikey, http basic, etc...)
o acl / security 
o autogen forms?
o proxy / load balancing
o datanode-client
o datanode shell (like mongo shell) (also restshell)?
o api versioning
o cursors for dbs
o RSS
o REST Envelope and non-envelope formats

Create a lot of examples

Doc up a list of Endpoint types with methods
  Endpoint
    Collection
    DataView / CollectionView *** OR SHOULD ALL COLLECTIONS HAVE VIEWS??????????????
       - maybe we do not need views on non data collections since if
        you want to make a view it should be easy enough subclassing
        Endpoint and using params
    DataForm / 
     

{
  _type: "datanode/CollectioView",
  collection: "todos",
  params: {
    color: {
       // swagger style? dont need everything (line "in" etc...)
    }
  },
  
  // query, queryTemplate, view, viewTemplate
  query: function(user, params) {
     return {
       query: { ... },
       sort: {},
       fields: {},
       ...
     }
  }
  
  query: {
     color: "@color",
     color: "@params.color",
     user: "@user.id"
  }

}

-------------------------

For Collections
   - supportsCollectionRead (find)
     - supportsCollectionQuery?
   - supportsCollectionUpdate (update)
   - supportsCollectionDelete (remove)
   - supportsObjectRead  (findById findOne)
   - supportsObjectCreate (insert)
   - supportsObjectUpdate (update, save)
   - supportsObjectDelete (removeById)

Tranforms?
  - Read transform (for collection and obj reads)
  - Write transform (for insert, update, and save) (or is update same
  as save?)

-------------------------

Inchworm example

supportsObjectCreate
supportsObjectRead
supportsObjectDelete

What is a View?
   

----------
Error handling

Maybe we define a BasicEndpoint that handles this:

{
  _type: 'datanode/BasicEndpoint',
  
  get: function(params, cb) {
     if (!params.foo) {
        cb(new InvalidParametersError("Foo parameter required"))
     } else {
       cb({foo: params.foo})
     }
  }
}

http://stackoverflow.com/questions/783818/how-do-i-create-a-custom-error-in-javascript
http://j-query.blogspot.com/2014/03/custom-error-objects-in-javascript.html

oo({
  _type: Error,
  code: 401
})

-------
% hexshell localhost:8080
> ls
todos users
> cd todos
> options // ls?
['get', 'post']
> GET
[...]
> POST {a: 1}
> this
{ ... meta ... }

o Can potentially use the Swagger spec that gets beamed
o Should also have non-interactive mode or another tool called hexc
that is more cmdline tool
o Maybe it should be a javascript shell? Like mongo? Ooooh
o 


-----------
Data binding

The big question is do we want db.getCollection('foo').find() to
return object bound to their classes yet? 

Related is how we do subobj types

And how do we do it if there is no db involved? 

----
UserOwnedMongoDBCollection
  collection: foo
  userIdProperty: user 

-----
Collection ACLs

{

  acl: {
    _type: 'datanode/EndpointAcl',
    entries: {
      "*": {   
        get: function(req) { return req.user.group === "FunkyGroup" },
        put: false,
        post: false,
        delete: false,
        head: false,
        options: false,
      },
      "role:Admin": {
         get: true,
         put: true,
         post: true,
         delete: false,
         head: true,
      },
      "title:CFO": {
         read: true,
         find: true,
         insert: true,
         update: true,
         delete: false,
      }
    }
}

{

  acl: {
    _type: 'datanode/CollectionAcl',
    permissionDefinitions: {
      read: false, // <perm>: <default>
      ...
    },
    groupDefinitions: {
      group: 'group',
      role: 'role',
    },
    entries: {
      "*": {   
        read: function(req) { return req.user.group === "FunkyGroup" },
        find: function(user) { return user.group === "FunkyGroup" },,
        insert: false,
        update: false,
        delete: false,
      },
      "role:Admin": {
         read: true,
         find: true,
         insert: true,
         update: true,
         delete: true,
      }
    }
}

OR

{ // private collection 

  __acls__: {
    "*": false 
}

{ // public collection 

  __acls__: {
    "*": true 
}

{ // local access collection 

  __acls__: {
    "*": function(req) { return req.ip === 127.0.0.1 } // XXX spoofable?
}

Doc ACLs

{

  __acl__: {
    "*": {
      read: false,
      write: false,
      delete: false,
      admin: false 
    },
    "user:1234": {
        read: true,
        write: true,
        delete: true,
        admin: true,
        owner: true // (maybe as owner he is the only one that can see 
                       acl properties (or as admin) 
    },
    "user:1234": {
        read: {
          "*": true,
          "ssn": false,
          "address.zip": false
        },
        write: false,
        delete: false,
        admin: false // XXX would we ever give someone else ability?
    }
    
  }
}

o Should we make roles more first class and hierarchical?
o Do we allow for overlapping acl rules? How do we deal with that?
o Do we strip objects of non-acl passing or just reject and require
fields mask from client call results in doc that passes acl 
o ACL infrastructure must be easy to use manually when not using
MongoDBCollection
o How do Collection ACLs differ from ACLs on Enpoints
  - probably just different permissions (http methods vs collection methods)
o Should have "root" user concept for the programmer (not app users)
  - pass / key configured in app (or db?)
  - bypasses all security (code can say req.user ==
  objectserver.rootUser) or something like that
  - 

How will we write MongoDBCollection?
collectionRead
  - will apply acl on each result object
collectionInsert
  - will apply ACL if exists on incoming object or add default acl
collectionUpdate
  - need to get the actual acl from each object before updating
  - may have to not impl as multi-update in mongodb and impl like this
    - get all objects that match query (can mask for just acl)
    - for each object look at acl
      - if passes acl then issue atomic update or save to single doc 
    - must convince this race is no worse than natural race
    - ** must make sure we look at the ACL on object in db as well as
    one coming in (if any)
    - ** must merge in existing ACLs on save so we don't stomp on them / remove them
    - ** may be able to optimize by augmenting query with matches on
    ACL ruls but could get complex with both property level ac as well
    as the possibility of many acls matching (role and user for example)
collectionCreate
  - TBD but probably no-op
collectionDelete
  - Same as update. 
objectRead
  - Just look at ACL
objectUpdate
  - Read first, check ACL and then apply update
objectDelete
  - Read first, check ACL and then delete


http://docs.spring.io/spring-security/site/docs/3.0.x/reference/domain-acls.html
http://www.cs.mun.ca/~michael/java/jdk1.1-beta2-docs/guide/security/Acl.html
------






